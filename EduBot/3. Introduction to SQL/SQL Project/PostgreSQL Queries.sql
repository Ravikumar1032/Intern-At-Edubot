--1. Define Database Structure
CREATE TABLE Users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(100) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL
);

CREATE TABLE Passwords (
    password_id SERIAL PRIMARY KEY,
    user_id INT REFERENCES Users(user_id),
    password VARCHAR(100) NOT NULL,
    creation_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Inserting data into Users table
INSERT INTO Users (username, email) VALUES
('Ravikumar', 'Ravi@gmail.com'),
('sajida', 'Sajida@gmail.com'),
('Hari', 'Hari@gmail.com');


-- Inserting data into Passwords table
INSERT INTO Passwords (user_id, password) VALUES
(1, 'A1b2C3d4!'),
(1, 'XyZ9876#'),
(2, 'P@ssw0rd!'),
(2, 'QwErTy123$'),
(3, 'Zxcv1234!'),
(3, 'AsDfGhJkL#');

-- SELECT * FROM Users;

-- SELECT * FROM Passwords;

-- 2. Implement SQL Triggers

-- Function to enforce password length constraint
CREATE OR REPLACE FUNCTION check_password_length()
RETURNS TRIGGER AS $$
BEGIN
    IF LENGTH(NEW.password) < 8 THEN
        RAISE EXCEPTION 'Password must be at least 8 characters long';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to call the function before inserting or updating passwords
CREATE TRIGGER password_length_trigger
BEFORE INSERT OR UPDATE ON Passwords
FOR EACH ROW EXECUTE FUNCTION check_password_length();

-- 3. Utilize SQL Functions
-- Function to count passwords generated by a user
CREATE OR REPLACE FUNCTION count_user_passwords(user_id INT)
RETURNS INT AS $$
DECLARE
    password_count INT;
BEGIN
    SELECT COUNT(*) INTO password_count
    FROM Passwords
    WHERE user_id = count_user_passwords.user_id;
    RETURN password_count;
END;
$$ LANGUAGE plpgsql;

SELECT user_id, COUNT(*) AS password_count
FROM Passwords
GROUP BY user_id;

-- 7.Example of using transactions to ensure data consistency
BEGIN;
UPDATE Users SET email = 'newemail@example.com' WHERE user_id = 1;
-- Other operations...
COMMIT;

SELECT email FROM users WHERE user_id = 1;

-- 8.Example of using GROUP BY and HAVING to find users with more than 5 passwords
SELECT user_id, COUNT(*) AS password_count
FROM Passwords
GROUP BY user_id
HAVING COUNT(*) > 5;

-- 9.Example of using COALESCE to provide default values for missing email data
SELECT COALESCE(email, 'noemail@example.com') AS email_value
FROM Users;

-- 10.Example of a stored procedure to fetch passwords for a user within a date range
CREATE OR REPLACE FUNCTION get_user_passwords(user_id INT, start_date DATE, end_date DATE)
RETURNS TABLE (password VARCHAR, creation_date TIMESTAMP) AS $$
BEGIN
    RETURN QUERY
    SELECT password, creation_date
    FROM Passwords
    WHERE user_id = get_user_passwords.user_id
    AND creation_date BETWEEN start_date AND end_date;
END;
$$ LANGUAGE plpgsql;

-- 11.Create a stored procedure to generate a new password and insert it into the Passwords table
CREATE OR REPLACE FUNCTION generate_and_insert_password(
    user_id_param INT,
    password_length INT
) RETURNS VOID AS $$
DECLARE
    new_password VARCHAR := '';
    characters TEXT := 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+';
    i INT := 0;
BEGIN
    -- Generate a random password
    FOR i IN 1..password_length LOOP
        new_password := new_password || substr(characters, floor(random() * length(characters) + 1), 1);
    END LOOP;
    
    -- Insert the new password into the Passwords table
    INSERT INTO Passwords (user_id, password) VALUES (user_id_param, new_password);
END;
$$ LANGUAGE plpgsql;
